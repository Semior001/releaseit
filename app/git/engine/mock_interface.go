// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package engine

import (
	"context"
	"github.com/Semior001/releaseit/app/git"
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
// 	func TestSomethingThatUsesInterface(t *testing.T) {
//
// 		// make and configure a mocked Interface
// 		mockedInterface := &InterfaceMock{
// 			CompareFunc: func(ctx context.Context, fromSHA string, toSHA string) (git.CommitsComparison, error) {
// 				panic("mock out the Compare method")
// 			},
// 			GetLastCommitOfBranchFunc: func(ctx context.Context, branch string) (string, error) {
// 				panic("mock out the GetLastCommitOfBranch method")
// 			},
// 			ListPRsOfCommitFunc: func(ctx context.Context, sha string) ([]git.PullRequest, error) {
// 				panic("mock out the ListPRsOfCommit method")
// 			},
// 			ListTagsFunc: func(ctx context.Context) ([]git.Tag, error) {
// 				panic("mock out the ListTags method")
// 			},
// 		}
//
// 		// use mockedInterface in code that requires Interface
// 		// and then make assertions.
//
// 	}
type InterfaceMock struct {
	// CompareFunc mocks the Compare method.
	CompareFunc func(ctx context.Context, fromSHA string, toSHA string) (git.CommitsComparison, error)

	// GetLastCommitOfBranchFunc mocks the GetLastCommitOfBranch method.
	GetLastCommitOfBranchFunc func(ctx context.Context, branch string) (string, error)

	// ListPRsOfCommitFunc mocks the ListPRsOfCommit method.
	ListPRsOfCommitFunc func(ctx context.Context, sha string) ([]git.PullRequest, error)

	// ListTagsFunc mocks the ListTags method.
	ListTagsFunc func(ctx context.Context) ([]git.Tag, error)

	// calls tracks calls to the methods.
	calls struct {
		// Compare holds details about calls to the Compare method.
		Compare []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromSHA is the fromSHA argument value.
			FromSHA string
			// ToSHA is the toSHA argument value.
			ToSHA string
		}
		// GetLastCommitOfBranch holds details about calls to the GetLastCommitOfBranch method.
		GetLastCommitOfBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
		}
		// ListPRsOfCommit holds details about calls to the ListPRsOfCommit method.
		ListPRsOfCommit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sha is the sha argument value.
			Sha string
		}
		// ListTags holds details about calls to the ListTags method.
		ListTags []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCompare               sync.RWMutex
	lockGetLastCommitOfBranch sync.RWMutex
	lockListPRsOfCommit       sync.RWMutex
	lockListTags              sync.RWMutex
}

// Compare calls CompareFunc.
func (mock *InterfaceMock) Compare(ctx context.Context, fromSHA string, toSHA string) (git.CommitsComparison, error) {
	if mock.CompareFunc == nil {
		panic("InterfaceMock.CompareFunc: method is nil but Interface.Compare was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		FromSHA string
		ToSHA   string
	}{
		Ctx:     ctx,
		FromSHA: fromSHA,
		ToSHA:   toSHA,
	}
	mock.lockCompare.Lock()
	mock.calls.Compare = append(mock.calls.Compare, callInfo)
	mock.lockCompare.Unlock()
	return mock.CompareFunc(ctx, fromSHA, toSHA)
}

// CompareCalls gets all the calls that were made to Compare.
// Check the length with:
//     len(mockedInterface.CompareCalls())
func (mock *InterfaceMock) CompareCalls() []struct {
	Ctx     context.Context
	FromSHA string
	ToSHA   string
} {
	var calls []struct {
		Ctx     context.Context
		FromSHA string
		ToSHA   string
	}
	mock.lockCompare.RLock()
	calls = mock.calls.Compare
	mock.lockCompare.RUnlock()
	return calls
}

// GetLastCommitOfBranch calls GetLastCommitOfBranchFunc.
func (mock *InterfaceMock) GetLastCommitOfBranch(ctx context.Context, branch string) (string, error) {
	if mock.GetLastCommitOfBranchFunc == nil {
		panic("InterfaceMock.GetLastCommitOfBranchFunc: method is nil but Interface.GetLastCommitOfBranch was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
	}{
		Ctx:    ctx,
		Branch: branch,
	}
	mock.lockGetLastCommitOfBranch.Lock()
	mock.calls.GetLastCommitOfBranch = append(mock.calls.GetLastCommitOfBranch, callInfo)
	mock.lockGetLastCommitOfBranch.Unlock()
	return mock.GetLastCommitOfBranchFunc(ctx, branch)
}

// GetLastCommitOfBranchCalls gets all the calls that were made to GetLastCommitOfBranch.
// Check the length with:
//     len(mockedInterface.GetLastCommitOfBranchCalls())
func (mock *InterfaceMock) GetLastCommitOfBranchCalls() []struct {
	Ctx    context.Context
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
	}
	mock.lockGetLastCommitOfBranch.RLock()
	calls = mock.calls.GetLastCommitOfBranch
	mock.lockGetLastCommitOfBranch.RUnlock()
	return calls
}

// ListPRsOfCommit calls ListPRsOfCommitFunc.
func (mock *InterfaceMock) ListPRsOfCommit(ctx context.Context, sha string) ([]git.PullRequest, error) {
	if mock.ListPRsOfCommitFunc == nil {
		panic("InterfaceMock.ListPRsOfCommitFunc: method is nil but Interface.ListPRsOfCommit was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sha string
	}{
		Ctx: ctx,
		Sha: sha,
	}
	mock.lockListPRsOfCommit.Lock()
	mock.calls.ListPRsOfCommit = append(mock.calls.ListPRsOfCommit, callInfo)
	mock.lockListPRsOfCommit.Unlock()
	return mock.ListPRsOfCommitFunc(ctx, sha)
}

// ListPRsOfCommitCalls gets all the calls that were made to ListPRsOfCommit.
// Check the length with:
//     len(mockedInterface.ListPRsOfCommitCalls())
func (mock *InterfaceMock) ListPRsOfCommitCalls() []struct {
	Ctx context.Context
	Sha string
} {
	var calls []struct {
		Ctx context.Context
		Sha string
	}
	mock.lockListPRsOfCommit.RLock()
	calls = mock.calls.ListPRsOfCommit
	mock.lockListPRsOfCommit.RUnlock()
	return calls
}

// ListTags calls ListTagsFunc.
func (mock *InterfaceMock) ListTags(ctx context.Context) ([]git.Tag, error) {
	if mock.ListTagsFunc == nil {
		panic("InterfaceMock.ListTagsFunc: method is nil but Interface.ListTags was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListTags.Lock()
	mock.calls.ListTags = append(mock.calls.ListTags, callInfo)
	mock.lockListTags.Unlock()
	return mock.ListTagsFunc(ctx)
}

// ListTagsCalls gets all the calls that were made to ListTags.
// Check the length with:
//     len(mockedInterface.ListTagsCalls())
func (mock *InterfaceMock) ListTagsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListTags.RLock()
	calls = mock.calls.ListTags
	mock.lockListTags.RUnlock()
	return calls
}
